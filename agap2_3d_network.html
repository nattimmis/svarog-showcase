<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AGAP2 - 3D Business Intelligence Network</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #0a0e27; font-family: Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; padding: 20px; color: white; z-index: 100; background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent); pointer-events: none; }
        #title { font-size: 24px; font-weight: bold; text-align: center; margin-bottom: 10px; background: linear-gradient(90deg, #ff006e, #00f5ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .controls { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 10px; pointer-events: auto; }
        .btn { padding: 10px 20px; background: rgba(0, 150, 255, 0.8); border: 1px solid #0096ff; color: white; border-radius: 5px; cursor: pointer; font-size: 14px; }
        .btn:hover { background: rgba(0, 150, 255, 1); }
        #info { position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border: 1px solid #0096ff; border-radius: 5px; color: #0096ff; font-size: 12px; pointer-events: auto; max-width: 300px; }
        #nodePanel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 30px; border: 2px solid #00f5ff; border-radius: 10px; color: white; display: none; z-index: 200; max-width: 400px; pointer-events: auto; }
        #nodePanel.active { display: block; }
        #nodePanel h3 { color: #00f5ff; margin-top: 0; }
        .close-btn { position: absolute; top: 10px; right: 15px; background: none; border: none; color: #ff006e; font-size: 28px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="overlay">
        <div id="title">ðŸŽ¯ AGAP2 - 3D Business Intelligence Network</div>
        <div class="controls">
            <button class="btn" onclick="resetView()">Reset View</button>
            <button class="btn" onclick="filterByType('all')">Show All</button>
            <button class="btn" onclick="filterByType('svarog')">SVAROG</button>
            <button class="btn" onclick="filterByType('niche')">Niches</button>
        </div>
    </div>

    <div id="info">
        <div><strong>Total Nodes:</strong> <span id="nodeCount">0</span></div>
        <div><strong>Visible:</strong> <span id="visibleCount">0</span></div>
        <div style="margin-top: 10px; font-size: 11px; color: #94a3b8;">
            ðŸ’¡ Scroll: Zoom | Drag: Rotate | Pinch: Zoom (mobile) | Click: Select
        </div>
    </div>

    <div id="nodePanel">
        <button class="close-btn" onclick="closePanel()">âœ•</button>
        <h3 id="panelTitle">Node</h3>
        <p id="panelContent"></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@r128/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ============ SCENE SETUP ============
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e27);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
        camera.position.set(0, 60, 200);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ============ LIGHTING ============
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 100, 100);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0x00f5ff, 0.5);
        pointLight.position.set(-100, 100, -100);
        scene.add(pointLight);

        // ============ CONTROLS ============
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false;
        controls.enableZoom = true;
        controls.zoomSpeed = 1.5;
        controls.minDistance = 20;
        controls.maxDistance = 500;

        // ============ DATA ============
        const nodes = [];
        const connections = [];
        let selectedNode = null;
        let currentFilter = 'all';

        const svarogData = [
            ["ai-automation", "AI Automation", "svarog"],
            ["ml-prediction", "ML Prediction", "svarog"],
            ["nlp-processing", "NLP Processing", "svarog"],
            ["computer-vision", "Computer Vision", "svarog"],
            ["data-analytics", "Data Analytics", "svarog"],
            ["predictive-maintenance", "Predictive Maintenance", "svarog"],
            ["anomaly-detection", "Anomaly Detection", "svarog"],
            ["recommendation-engine", "Recommendation Engine", "svarog"],
            ["time-series", "Time Series Analysis", "svarog"],
            ["deep-learning", "Deep Learning", "svarog"],
            ["neural-networks", "Neural Networks", "svarog"],
            ["reinforcement", "Reinforcement Learning", "svarog"],
            ["knowledge-graphs", "Knowledge Graphs", "svarog"],
            ["semantic-search", "Semantic Search", "svarog"],
            ["sentiment", "Sentiment Analysis", "svarog"]
        ];

        const nicheData = [
            ["fintech", "FinTech", "niche"],
            ["healthcare", "Healthcare", "niche"],
            ["ecommerce", "E-Commerce", "niche"],
            ["manufacturing", "Manufacturing", "niche"],
            ["logistics", "Logistics", "niche"],
            ["agriculture", "Agriculture", "niche"],
            ["energy", "Energy", "niche"],
            ["education", "Education", "niche"],
            ["transportation", "Transportation", "niche"],
            ["retail", "Retail", "niche"],
            ["real-estate", "Real Estate", "niche"],
            ["hospitality", "Hospitality", "niche"],
            ["media", "Media & Entertainment", "niche"],
            ["telecom", "Telecommunications", "niche"],
            ["insurance", "Insurance", "niche"]
        ];

        // ============ NODE CREATION ============
        function getColor(type) {
            const colors = { svarog: 0xff006e, niche: 0xa855f7, hub: 0xfbbf24 };
            return colors[type] || 0x22c55e;
        }

        function createNode(data, type, position = null) {
            // NODE SIZE IS 10 UNITS - CLEARLY VISIBLE
            const geometry = new THREE.IcosahedronGeometry(10, 4);
            const color = getColor(type);
            const material = new THREE.MeshStandardMaterial({
                color: color,
                emissive: color,
                emissiveIntensity: 0.5,
                metalness: 0.3,
                roughness: 0.4
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            if (position) {
                mesh.position.copy(position);
            } else {
                mesh.position.set(
                    (Math.random() - 0.5) * 250,
                    (Math.random() - 0.5) * 250,
                    (Math.random() - 0.5) * 250
                );
            }

            mesh.userData = {
                name: data[1],
                slug: data[0],
                type: type || data[2],
                isNode: true
            };

            scene.add(mesh);
            return mesh;
        }

        function createConnection(from, to) {
            const positions = new Float32Array([
                from.position.x, from.position.y, from.position.z,
                to.position.x, to.position.y, to.position.z
            ]);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const material = new THREE.LineBasicMaterial({
                color: 0x00f5ff,
                transparent: true,
                opacity: 0.15,
                linewidth: 1
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            return { from, to, line };
        }

        // ============ CREATE HUB ============
        const hubGeometry = new THREE.IcosahedronGeometry(15, 4);
        const hubMaterial = new THREE.MeshStandardMaterial({
            color: 0xfbbf24,
            emissive: 0xfbbf24,
            emissiveIntensity: 0.7,
            metalness: 0.4,
            roughness: 0.3
        });
        const hubNode = new THREE.Mesh(hubGeometry, hubMaterial);
        hubNode.position.set(0, 0, 0);
        hubNode.userData = { name: "AGAP2 Hub", type: "hub", isHub: true };
        scene.add(hubNode);
        nodes.push(hubNode);

        // ============ ADD SVAROG NODES ============
        svarogData.forEach((data, idx) => {
            const angle = (idx / svarogData.length) * Math.PI * 2;
            const radius = 100;
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 50,
                Math.sin(angle) * radius
            );
            const node = createNode(data, "svarog", pos);
            nodes.push(node);
            connections.push(createConnection(hubNode, node));
        });

        // ============ ADD NICHE NODES ============
        nicheData.forEach((data, idx) => {
            const angle = (idx / nicheData.length) * Math.PI * 2;
            const radius = 160;
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 80,
                Math.sin(angle) * radius
            );
            const node = createNode(data, "niche", pos);
            nodes.push(node);
            connections.push(createConnection(hubNode, node));
        });

        document.getElementById('nodeCount').textContent = nodes.length;
        document.getElementById('visibleCount').textContent = nodes.length;

        // ============ INTERACTION ============
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('click', (e) => {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(nodes);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                if (!obj.userData.isHub) {
                    selectNode(obj);
                }
            } else {
                closePanel();
            }
        });

        function selectNode(node) {
            if (selectedNode) selectedNode.material.emissiveIntensity = 0.5;
            selectedNode = node;
            node.material.emissiveIntensity = 1;

            document.getElementById('panelTitle').textContent = node.userData.name;
            document.getElementById('panelContent').innerHTML = `
                <p><strong>Type:</strong> ${node.userData.type}</p>
                <p><strong>Slug:</strong> ${node.userData.slug}</p>
                <p style="margin-top: 15px; font-size: 11px; color: #94a3b8;">Click nodes to explore the 3D network</p>
            `;
            document.getElementById('nodePanel').classList.add('active');
        }

        function closePanel() {
            if (selectedNode) selectedNode.material.emissiveIntensity = 0.5;
            selectedNode = null;
            document.getElementById('nodePanel').classList.remove('active');
        }

        function filterByType(type) {
            currentFilter = type;
            const visibleCount = nodes.filter(n => {
                if (type === 'all' || n.userData.type === type || n.userData.isHub) {
                    n.visible = true;
                    return true;
                } else {
                    n.visible = false;
                    return false;
                }
            }).length;
            document.getElementById('visibleCount').textContent = visibleCount;
        }

        function resetView() {
            camera.position.set(0, 60, 200);
            controls.target.set(0, 0, 0);
            controls.update();
            closePanel();
            filterByType('all');
        }

        // ============ TOUCH PINCH ZOOM ============
        let lastDistance = 0;

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const delta = currentDistance - lastDistance;

                const direction = camera.position.normalize();
                const distance = camera.position.length();
                const newDistance = distance - (delta * 0.5);

                if (newDistance > controls.minDistance && newDistance < controls.maxDistance) {
                    camera.position.copy(direction.multiplyScalar(newDistance));
                }

                lastDistance = currentDistance;
                e.preventDefault();
            }
        });

        // ============ UPDATE CONNECTIONS ============
        controls.addEventListener('change', () => {
            connections.forEach(conn => {
                const pos = conn.line.geometry.attributes.position.array;
                pos[0] = conn.from.position.x;
                pos[1] = conn.from.position.y;
                pos[2] = conn.from.position.z;
                pos[3] = conn.to.position.x;
                pos[4] = conn.to.position.y;
                pos[5] = conn.to.position.z;
                conn.line.geometry.attributes.position.needsUpdate = true;
            });
        });

        // ============ WINDOW RESIZE ============
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // ============ ANIMATION LOOP ============
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
